*pcntl_signal*

(PHP 4 >= 4.1.0, PHP 5, PHP 7)

pcntl_signal â€” Installs a signal handler

===============================================================================
[ Description ]

  pcntl_signal ( int $signo , callable|int $handler [, bool $restart_syscalls~
  = TRUE ] ) : bool~

The pcntl_signal() function installs a new signal handler or replaces the
current signal handler for the signal indicated by {signo}.

===============================================================================
[ Parameters ]

{signo}

  The signal number.

{handler}

  The signal handler. This may be either a callable, which will be invoked to
  handle the signal, or either of the two global constants SIG_IGN or SIG_DFL,
  which will ignore the signal or restore the default signal handler
  respectively.

  If a callable is given, it must implement the following signature:


  handler ( int $signo , mixed $signinfo ) : void~

  {signo}
    The signal being handled.
  {siginfo}
    If operating systems supports siginfo_t structures, this will be an array
    of signal information dependent on the signal.

    Note:

    Note that when you set a handler to an object method, that object's
    reference count is increased which makes it persist until you either change
    the handler to something else, or your script ends.

{restart_syscalls}

  Specifies whether system call restarting should be used when this signal
  arrives.

===============================================================================
[ Return Values ]

Returns TRUE on success or FALSE on failure.

===============================================================================
[ Changelog ]

Version                               Description
        As of PHP 4.3.0 PCNTL uses ticks as the signal handle callback
        mechanism, which is much faster than the previous mechanism. This
4.3.0   change follows the same semantics as using "user ticks". You must use
        the declare() statement to specify the locations in your program where
        callbacks are allowed to occur for the signal handler to function
        properly (as used in the example below).
        As of PHP 7.1.0 the handler callback is given a second argument
7.1.0   containing the signinfo of the specific signal. This data is only
        supplied if the operating system has the signinfo_t structure. If the
        OS does not implement siginfo_t NULL is supplied.

===============================================================================
[ Examples ]

Example #1 pcntl_signal() example

<?php >
  // tick use required as of PHP 4.3.0
  declare(ticks = 1);

  // signal handler function
  function sig_handler($signo)
  {

       switch ($signo) {
           case SIGTERM:
               // handle shutdown tasks
               exit;
               break;
           case SIGHUP:
               // handle restart tasks
               break;
           case SIGUSR1:
               echo "Caught SIGUSR1...\n";
               break;
           default:
               // handle all other signals
       }

  }

  echo "Installing signal handler...\n";

  // setup signal handlers
  pcntl_signal(SIGTERM, "sig_handler");
  pcntl_signal(SIGHUP,  "sig_handler");
  pcntl_signal(SIGUSR1, "sig_handler");

  // or use an object, available as of PHP 4.3.0
  // pcntl_signal(SIGUSR1, array($obj, "do_something"));

  echo"Generating signal SIGUSR1 to self...\n";

  // send SIGUSR1 to current process id
  // posix_* functions require the posix extension
  posix_kill(posix_getpid(), SIGUSR1);

  echo "Done\n";

<?>

===============================================================================
[ Notes ]

pcntl_signal() doesn't stack the signal handlers, but replaces them.

===============================================================================
[ See Also ]

 * |pcntl_fork| - Forks the currently running process
 * |pcntl_waitpid| - Waits on or returns the status of a forked child


vim:ft=help: